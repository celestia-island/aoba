pub mod app;
pub mod input;
pub mod ui;

use anyhow::Result;
use ratatui::{backend::CrosstermBackend, prelude::*};
use std::io::{self, Stdout};
use std::time::Duration;

use crate::tui::input::{map_key, Action};
use app::App;
use std::sync::{Arc, Mutex};
use std::thread;

pub fn start() -> Result<()> {
    log::info!("[TUI] aoba TUI starting...");

    // Setup terminal
    let mut stdout = io::stdout();
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(stdout, crossterm::terminal::EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(&mut stdout);
    let mut terminal = Terminal::new(backend)?;

    let app = Arc::new(Mutex::new(App::new()));

    // background refresher thread
    {
        let app_clone = Arc::clone(&app);
        thread::spawn(move || loop {
            thread::sleep(std::time::Duration::from_secs(3));
            let mut guard = app_clone.lock().unwrap();
            if guard.auto_refresh {
                guard.refresh();
            }
        });
    }

    let res = run_app(&mut terminal, Arc::clone(&app));

    // Restore terminal
    let mut stdout = io::stdout();
    crossterm::execute!(stdout, crossterm::terminal::LeaveAlternateScreen)?;
    crossterm::terminal::disable_raw_mode()?;

    res
}

fn run_app(
    terminal: &mut Terminal<CrosstermBackend<&mut Stdout>>,
    app: Arc<Mutex<App>>,
) -> Result<()> {
    loop {
        // draw with short-lived lock
        {
            let guard = app.lock().unwrap();
            terminal.draw(|f| crate::tui::ui::render_ui(f, &*guard))?;
        }

        // Poll for input
        if crossterm::event::poll(Duration::from_millis(200))? {
            if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
                // Ignore repeated key events generated by key holding or platform quirks
                // so a single key press maps to a single action.
                if let crossterm::event::KeyEventKind::Repeat = key.kind {
                    continue;
                }

                match map_key(key.code) {
                    Action::Quit => break,
                    Action::FocusLeft => {
                        let mut guard = app.lock().unwrap();
                        guard.focus = app::Focus::Left;
                    }
                    Action::FocusRight => {
                        let mut guard = app.lock().unwrap();
                        guard.focus = app::Focus::Right;
                    }
                    Action::MoveNext => {
                        let mut guard = app.lock().unwrap();
                        if matches!(guard.focus, app::Focus::Left) {
                            guard.next();
                        }
                    }
                    Action::MovePrev => {
                        let mut guard = app.lock().unwrap();
                        if matches!(guard.focus, app::Focus::Left) {
                            guard.prev();
                        }
                    }
                    Action::Refresh => {
                        let mut guard = app.lock().unwrap();
                        guard.refresh();
                    }
                    Action::ToggleAutoRefresh => {
                        let mut guard = app.lock().unwrap();
                        guard.toggle_auto_refresh();
                    }
                    Action::None => {}
                }
            }
        }
    }

    terminal.clear()?;
    Ok(())
}
